package com.isl.leaseManagement.bts.captureCandidate.propertyDetails

import android.graphics.Rect
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewTreeObserver
import android.widget.AdapterView
import android.widget.Spinner
import androidx.lifecycle.lifecycleScope
import com.isl.itower.MyApp
import com.isl.leaseManagement.api.ApiClient
import com.isl.leaseManagement.base.BaseFragment
import com.isl.leaseManagement.bts.adapter.AreaType
import com.isl.leaseManagement.bts.adapter.SpinnerGenericAPILovAdapter
import com.isl.leaseManagement.bts.adapter.SpinnerGenericLocationAdapter
import com.isl.leaseManagement.bts.adapter.SpinnerGenericYesNoAdapter
import com.isl.leaseManagement.dataClasses.responses.CandidateDetailsAPIResponse
import com.isl.leaseManagement.dataClasses.responses.DropdownDataResponse
import com.isl.leaseManagement.dataClasses.responses.ExistingCandidateListResponse
import com.isl.leaseManagement.dataClasses.responses.LocationsListResponse
import com.isl.leaseManagement.dataClasses.responses.UpdatePropertyResponse
import com.isl.leaseManagement.sharedPref.KotlinPrefkeeper
import com.isl.leaseManagement.utils.ActionButtonMethods
import com.isl.leaseManagement.utils.AppConstants
import com.isl.leaseManagement.utils.MessageConstants.ErrorMessages.fieldsCleared
import com.isl.leaseManagement.utils.MessageConstants.ErrorMessages.mandatoryFieldsAreRequired
import com.isl.leaseManagement.utils.MessageConstants.ErrorMessages.pleaseEnterValidLatitude
import com.isl.leaseManagement.utils.MessageConstants.ErrorMessages.pleaseEnterValidLongitude
import com.isl.leaseManagement.utils.Utilities.getLocationListForUniqueRegions
import com.isl.leaseManagement.utils.Utilities.getLocationsListForCitiesInDistrict
import com.isl.leaseManagement.utils.Utilities.getLocationsListForDistrictsInRegion
import infozech.itower.R
import infozech.itower.databinding.FragmentEssentialPropertyBinding
import io.reactivex.Observable
import io.reactivex.Observer
import io.reactivex.android.schedulers.AndroidSchedulers
import io.reactivex.disposables.Disposable
import io.reactivex.schedulers.Schedulers
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

class EssentialPropertyFragment : BaseFragment() {

    private lateinit var binding: FragmentEssentialPropertyBinding
    private var disposable: Disposable? = null
    private var currentCandidateDetailsResponse =
        CandidateDetailsAPIResponse(     // initially passing 0,will update this later and  will use this throughout
            0,
            null, null, null, null, null
        )
    private var autoGeneratedId = 0
    private var candidateOrLandlordName: String? = "NA"
    private val api = ApiClient.request

    private lateinit var areaTypeAdapter: SpinnerGenericAPILovAdapter
    private lateinit var leaseSpaceTypeAdapter: SpinnerGenericAPILovAdapter
    private lateinit var siteTypeAdapter: SpinnerGenericAPILovAdapter
    private lateinit var accessRoadAdapter: SpinnerGenericAPILovAdapter
    private lateinit var powerSourceTypeAdapter: SpinnerGenericAPILovAdapter

    private lateinit var regionAdapter: SpinnerGenericLocationAdapter
    private lateinit var districtAdapter: SpinnerGenericLocationAdapter
    private lateinit var cityAdapter: SpinnerGenericLocationAdapter

    private val completeDropdownList =
        KotlinPrefkeeper.dropdownsList
            ?: DropdownDataResponse() // empty to avoid null exception
    private val areaTypeList =
        completeDropdownList.getDropdownsListByParamType(AppConstants.DropDownParamTypes.areaType)
    private val leaseSpaceTypeList =
        completeDropdownList.getDropdownsListByParamType(AppConstants.DropDownParamTypes.leasedSpaceType)
    private val siteTypeList =
        completeDropdownList.getDropdownsListByParamType(AppConstants.DropDownParamTypes.siteType)
    private val accessRoadList =
        completeDropdownList.getDropdownsListByParamType(AppConstants.DropDownParamTypes.accessRoad)
    private val powerSourceTypeList =
        completeDropdownList.getDropdownsListByParamType(AppConstants.DropDownParamTypes.powerSourceType)

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        binding = FragmentEssentialPropertyBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        init()
    }

    private fun init() {
        getDataFromIntent()
        attachValuesToAPISpinners()
        attachValuesToYesNoSpinner()
        if (autoGeneratedId != 0) {
            getCandidateData()
        } else {
            // set up regions
            val uniqueRegions: List<LocationsListResponse.LocationsListResponseItem>? =
                getLocationListForUniqueRegions()
            attachValuesToLocationsSpinners(uniqueRegions = uniqueRegions)
        }
        setClickListeners()
        ensureValidateLatitudeInput()
        ensureValidateLongitudeInput()
        //   setupKeyboardVisibilityListener()
    }

    private fun getDataFromIntent() {
        autoGeneratedId =
            (arguments?.getString(AppConstants.IntentKeys.autoGeneratedId)?.toInt()) ?: 0
        candidateOrLandlordName =
            (arguments?.getString(AppConstants.IntentKeys.candidateOrLandlordName)) ?: "NA"
    }

    private fun attachValuesToYesNoSpinner() {
        createAdapterAndAttachToYesNoSpinner(binding.momraRegulationsSpinner)
        createAdapterAndAttachToYesNoSpinner(binding.availablePowerSourceOwnerSpinner)
        createAdapterAndAttachToYesNoSpinner(binding.obstructionsExistSpinner)
        createAdapterAndAttachToYesNoSpinner(binding.landlordApprovalSpinner)
        createAdapterAndAttachToYesNoSpinner(binding.landDeedAvailableSpinner)
    }

    private fun createAdapterAndAttachToYesNoSpinner(spinner: Spinner) {
        val adapter = SpinnerGenericYesNoAdapter(
            context = baseActivity
        )
        adapter.attachSpinner(spinner)
    }

    private fun attachValuesToAPISpinners() {
        areaTypeAdapter = createAPISpinnerAdapter(areaTypeList)
        leaseSpaceTypeAdapter = createAPISpinnerAdapter(leaseSpaceTypeList)
        siteTypeAdapter = createAPISpinnerAdapter(siteTypeList)
        accessRoadAdapter = createAPISpinnerAdapter(accessRoadList)
        powerSourceTypeAdapter = createAPISpinnerAdapter(powerSourceTypeList)

        areaTypeAdapter.attachSpinner(binding.areaTypeSpinner)
        leaseSpaceTypeAdapter.attachSpinner(binding.leaseSpaceTypeSpinner)
        siteTypeAdapter.attachSpinner(binding.siteTypeSpinner)
        accessRoadAdapter.attachSpinner(binding.accessRoadRequiredSpinner)
        powerSourceTypeAdapter.attachSpinner(binding.powerSourceTypeSpinner)

        // for the 2 dependent dropdowns
        selectionChangeTriggerForSiteType()
        selectionChangeTriggerForPowerSourceType()
    }

    private var isRooftopSelected = false
    private var siteTypeValueSelected =
        ""   // defining as after calling it's click listener in this activity, selection not working

    private fun selectionChangeTriggerForSiteType() {
        binding.siteTypeSpinner.onItemSelectedListener =
            object : AdapterView.OnItemSelectedListener {
                override fun onItemSelected(
                    parent: AdapterView<*>,
                    view: View?,
                    position: Int,
                    id: Long
                ) {
                    val selectedItem =
                        parent.getItemAtPosition(position) as DropdownDataResponse.DropdownDataResponseItem?
                    selectedItem?.paramValue?.let {
                        siteTypeValueSelected = it
                        if (it == "Rooftop") {
                            isRooftopSelected = true
                            createAdapterAndAttachToYesNoSpinner(binding.pentHouseAvailableSpinner)
                            binding.approxBuildingHeightWithoutParaperET.isEnabled = true

                            binding.approxBuildingHeightWithoutParaperET.background =
                                baseActivity.getDrawable(R.drawable.btn_light_grey_border_bg)
                            binding.pentHouseAvailableSpinner.background =
                                baseActivity.getDrawable(R.drawable.btn_light_grey_border_bg)


                            val candidateDetailsDao =
                                baseActivity.commonDatabase.candidateDetailsDao()
                            disposable = candidateDetailsDao.getCandidateDetailsByAutoGeneratedId(
                                autoGeneratedId
                            )
                                .subscribeOn(Schedulers.io())
                                .observeOn(AndroidSchedulers.mainThread())
                                .subscribe(
                                    { candidateDetailsResponse ->
                                        if (candidateDetailsResponse.propertyDetail?.pentHouseAvailable != null) { // need to get candidate details
                                            selectPositionForYesNoSpinners(
                                                binding.pentHouseAvailableSpinner,
                                                candidateDetailsResponse.propertyDetail?.pentHouseAvailable
                                            )
                                        }
                                    },
                                    { error -> // error as details not present so, not filling details
                                    })


                        } else {
                            isRooftopSelected = false
                            binding.pentHouseAvailableSpinner.adapter = null
                            binding.approxBuildingHeightWithoutParaperET.isEnabled = false
                            binding.approxBuildingHeightWithoutParaperET.setText("")
                            binding.pentHouseAvailableSpinner.background =
                                baseActivity.getDrawable(R.drawable.bg_filled_grey_rounded)
                            binding.approxBuildingHeightWithoutParaperET.background =
                                baseActivity.getDrawable(R.drawable.bg_filled_grey_rounded)
                        }
                    }
                }

                override fun onNothingSelected(parent: AdapterView<*>) {
                }
            }
    }

    private var isSCECOSelected = false
    private var powerSourceTypeValueSelected =
        ""   // defining as after calling it's click listener in this activity, selection not working

    private fun selectionChangeTriggerForPowerSourceType() {
        binding.powerSourceTypeSpinner.onItemSelectedListener =
            object : AdapterView.OnItemSelectedListener {
                override fun onItemSelected(
                    parent: AdapterView<*>,
                    view: View?,
                    position: Int,
                    id: Long
                ) {
                    val selectedItem =
                        parent.getItemAtPosition(position) as DropdownDataResponse.DropdownDataResponseItem?
                    selectedItem?.paramValue?.let {
                        powerSourceTypeValueSelected = it
                        checkIfSCECOClicked(it)
                    }
                }

                override fun onNothingSelected(parent: AdapterView<*>) {
                }
            }
    }

    private fun checkIfSCECOClicked(s: String) {
        if (s == "SCECO") {

            isSCECOSelected = true

            //enabling all 4 fields
            createAdapterAndAttachToYesNoSpinner(binding.ownerApprovalToInstallSubStationSpinner)
            createAdapterAndAttachToYesNoSpinner(binding.secoAccessToRoadSpinner)
            binding.powerSourceDistanceSubstationET.isEnabled = true
            binding.powerSourceDistanceRoadET.isEnabled = true

            //changing all 4 fields BG
            binding.ownerApprovalToInstallSubStationSpinner.background =
                baseActivity.getDrawable(R.drawable.btn_light_grey_border_bg)
            binding.secoAccessToRoadSpinner.background =
                baseActivity.getDrawable(R.drawable.btn_light_grey_border_bg)
            binding.powerSourceDistanceSubstationET.background =
                baseActivity.getDrawable(R.drawable.btn_light_grey_border_bg)
            binding.powerSourceDistanceRoadET.background =
                baseActivity.getDrawable(R.drawable.btn_light_grey_border_bg)

            val candidateDetailsDao =
                baseActivity.commonDatabase.candidateDetailsDao()
            disposable = candidateDetailsDao.getCandidateDetailsByAutoGeneratedId(
                autoGeneratedId
            )
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { candidateDetailsResponse ->
                        if (candidateDetailsResponse.propertyDetail?.ownerApprovalToInstallSubStation != null) {
                            selectPositionForYesNoSpinners(
                                binding.ownerApprovalToInstallSubStationSpinner,
                                candidateDetailsResponse.propertyDetail?.ownerApprovalToInstallSubStation
                            )
                        }
                        if (candidateDetailsResponse.propertyDetail?.scecoAccessToRoad != null) {
                            selectPositionForYesNoSpinners(
                                binding.secoAccessToRoadSpinner,
                                candidateDetailsResponse.propertyDetail?.scecoAccessToRoad
                            )
                        }
                    },
                    { error -> // error as details not present so, not filling details
                    })


        } else {
            isSCECOSelected = false
            binding.ownerApprovalToInstallSubStationSpinner.adapter = null
            binding.secoAccessToRoadSpinner.adapter = null
            binding.powerSourceDistanceSubstationET.isEnabled = false
            binding.powerSourceDistanceSubstationET.setText("")
            binding.powerSourceDistanceRoadET.isEnabled = false
            binding.powerSourceDistanceRoadET.setText("")

            binding.ownerApprovalToInstallSubStationSpinner.background =
                baseActivity.getDrawable(R.drawable.bg_filled_grey_rounded)
            binding.secoAccessToRoadSpinner.background =
                baseActivity.getDrawable(R.drawable.bg_filled_grey_rounded)
            binding.powerSourceDistanceSubstationET.background =
                baseActivity.getDrawable(R.drawable.bg_filled_grey_rounded)
            binding.powerSourceDistanceRoadET.background =
                baseActivity.getDrawable(R.drawable.bg_filled_grey_rounded)
        }
    }

    private fun createAPISpinnerAdapter(dropdownList: DropdownDataResponse): SpinnerGenericAPILovAdapter {
        return SpinnerGenericAPILovAdapter(
            context = baseActivity,
            items = dropdownList
        )
    }

    private fun setClickListeners() {
        binding.saveAsDraftBtn.setOnClickListener {
            lifecycleScope.launch(Dispatchers.Main) {  // for avoiding creating multiple NA items on initial install
                checkAutoGenUniqueIdAndSaveToRoom(false)
                binding.saveAsDraftBtn.isEnabled =false
                delay(2000)
                binding.saveAsDraftBtn.isEnabled =true
            }
        }
        binding.saveToApiAndDraft.setOnClickListener { checkAutoGenUniqueIdAndSaveToRoom(true) }
        binding.siteAreaLengthWidthET.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
                // No action needed before text changes
            }

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                // No action needed during text changes
            }

            override fun afterTextChanged(s: Editable?) {
                val newText = s?.toString() ?: ""
                if (newText.isNotEmpty()) {
                    val area = multiplyExpression(newText)
                    binding.leaseAreaET.setText(area?.toString() ?: "")
                }
            }
        })
        binding.clearAllTv.setOnClickListener {
            clearAllClicked()
        }
        binding.actionBtn.setOnClickListener {
            ActionButtonMethods.Actions.showActionPopup(
                baseActivity, ActionButtonMethods.ActionOpeningProcess.BtsCaptureCandidate
            )
        }
    }

    private fun ensureValidateLatitudeInput() {
        val latitudeEditText = binding.latitudeEt

        latitudeEditText.addTextChangedListener(object : TextWatcher {
            override fun afterTextChanged(s: Editable?) {
                val text = s.toString()
                if (text.isNotEmpty()) {
                    try {
                        val value = text.toDouble()
                        if (value < -90 || value > 90) {
                            latitudeEditText.setText("")
                            baseActivity.showToastMessage(pleaseEnterValidLatitude)
                        }

                    } catch (e: NumberFormatException) {
                        latitudeEditText.setText("")
                        baseActivity.showToastMessage(pleaseEnterValidLatitude)
                    }
                }
            }

            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
                // No action needed
            }

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                // No action needed
            }
        })


    }

    private fun ensureValidateLongitudeInput() {
        val longitudeEditText = binding.longitudeEt

        longitudeEditText.addTextChangedListener(object : TextWatcher {
            override fun afterTextChanged(s: Editable?) {
                val text = s.toString()
                if (text.isNotEmpty()) {
                    try {
                        val value = text.toDouble()
                        if (value < -180 || value > 180) {
                            longitudeEditText.setText("")
                            baseActivity.showToastMessage(pleaseEnterValidLongitude)
                        }

                    } catch (e: NumberFormatException) {
                        longitudeEditText.setText("")
                        baseActivity.showToastMessage(pleaseEnterValidLongitude)
                    }
                }
            }

            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
                // No action needed
            }

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                // No action needed
            }
        })
    }


    private fun clearAllClicked() {
        fillCandidateDetails(
            candidateDetailsResponse = CandidateDetailsAPIResponse(    // only use it to set data, not saving it
                autoGeneratedId = autoGeneratedId, candidateId = null,

                accountDetails = null, delegateDetail = null, landlordDetail = null,
                propertyDetail = CandidateDetailsAPIResponse.PropertyDetails()
            ), true
        )
        attachValuesToAPISpinners()  // reattaching
        attachValuesToYesNoSpinner()

        binding.pentHouseAvailableSpinner.adapter =
            null   // clearing manually as these are not defined their
        binding.ownerApprovalToInstallSubStationSpinner.adapter = null
        binding.secoAccessToRoadSpinner.adapter = null

        isRooftopSelected = false
        siteTypeValueSelected = ""

        isSCECOSelected = false
        powerSourceTypeValueSelected = ""
        baseActivity.showToastMessage(fieldsCleared)
    }

    fun multiplyExpression(expression: String): Int? {
        val parts = expression.split("*")
        return if (parts.size == 2) {
            // Try to parse both numbers
            val number1 = parts[0].trim().toIntOrNull()
            val number2 = parts[1].trim().toIntOrNull()

            if (number1 != null && number2 != null) {
                number1 * number2
            } else {
                null // Return null if either part is not a valid number
            }
        } else {
            null // Return null if the format is incorrect or '*' is missing
        }
    }

    private fun checkAutoGenUniqueIdAndSaveToRoom(saveToApi: Boolean) {
        if (autoGeneratedId == 0) {  // new candidate so creating new Unique ID, unique in existing captured candidate table as well
            val existingCapturedCandidateDao =
                baseActivity.commonDatabase.existingCandidateListResponseItemDao()
            disposable = existingCapturedCandidateDao.getMaxId().subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread()).subscribe(
                    { maxId ->
                        autoGeneratedId =
                            (maxId
                                ?: 0) + 1  // Increment the max ID, or start from 1 if no IDs exist
                        updateCandidateForSavingToRoom(saveToApi)   // saving with new ID
                    }, { error ->
                        updateCandidateForSavingToRoom(saveToApi)
                    }
                )
        } else {
            updateCandidateForSavingToRoom(saveToApi)  // saving with pre existing Unique ID
        }
    }

    private fun updateCandidateForSavingToRoom(saveToApi: Boolean) {
        currentCandidateDetailsResponse.autoGeneratedId = autoGeneratedId
        if (currentCandidateDetailsResponse.propertyDetail == null) {  //if it is blank that is not saved yet, creating new
            currentCandidateDetailsResponse.propertyDetail =
                CandidateDetailsAPIResponse.PropertyDetails()
        }
        currentCandidateDetailsResponse.propertyDetail!!.let {  //now, can not be null
                property ->

            property.landlordPrice = binding.landlordPriceEt.text.toString()
            property.siteAddress = binding.siteAddressET.text.toString()
            property.siteDistrictLocal = binding.siteDistrictArabicValue.text.toString()
            property.siteCityLocal = binding.siteCityArabicValue.text.toString()
            property.siteStreet = binding.siteStreetEt.text.toString()
            property.siteStreetInArabic = binding.siteStreetArabicEt.text.toString()
            property.distanceFromRoadInMeter =
                binding.distanceFromRoadEt.text.toString().toDoubleOrNull() ?: 0.0
            property.siteNeighbourhood = binding.siteNeighbourhoodEt.text.toString()
            property.siteNeighbourhoodInArabic = binding.siteNeighbourhoodArabicEt.text.toString()

            property.latitude = binding.latitudeEt.text.toString()
            property.longitude = binding.longitudeEt.text.toString()
            property.distanceFromNominalInMeter =
                binding.distanceFromNominalValue.text.toString().toDoubleOrNull() ?: 0.0

            property.approxBuildingHeightWithoutParapetInMeter =
                binding.approxBuildingHeightWithoutParaperET.text.toString().toDoubleOrNull() ?: 0.0


            property.powerSourceDistanceFromSubstation =
                binding.powerSourceDistanceSubstationET.text.toString().toDoubleOrNull() ?: 0.0
            property.powerSourceDistanceFromRoad =
                binding.powerSourceDistanceRoadET.text.toString().toDoubleOrNull() ?: 0.0
            property.siteArea = binding.siteAreaLengthWidthET.text.toString()
            property.leaseAreaInSqMtr = binding.leaseAreaET.text.toString().toDoubleOrNull() ?: 0.0
            property.nearestElectricityPointDistanceInMeter =
                binding.nearestElectricityPointDistanceET.text.toString().toDoubleOrNull() ?: 0.0
            property.distanceFromNearestOperatorTower =
                binding.distanceFromNearestOperatorET.text.toString().toDoubleOrNull() ?: 0.0
            property.potentialPropertyStatus = binding.potentialPropertyStatusET.text.toString()


            //getting and saving from location spinners
            val selectedRegion = binding.regionSpinner.selectedItem
            if (selectedRegion is LocationsListResponse.LocationsListResponseItem) {
                val regionName = selectedRegion.regionName
                property.region = regionName
            } else {
                property.region = ""
            }

            // For district
            val selectedDistrict = binding.districtSpinner.selectedItem
            if (selectedDistrict is LocationsListResponse.LocationsListResponseItem) {
                val districtName = selectedDistrict.districtName
                property.siteDistrict =
                    districtName
            } else {
                property.siteDistrict = ""
            }

            // For city
            val selectedCity = binding.citySpinner.selectedItem
            if (selectedCity is LocationsListResponse.LocationsListResponseItem) {
                val cityName = selectedCity.cityName
                property.siteCity = cityName
            } else {
                property.siteCity = ""
            }

            //getting data from API spinners
            property.areaType = areaTypeAdapter.getSelectedItem()?.paramValue
            property.leasedSpaceType = leaseSpaceTypeAdapter.getSelectedItem()?.paramValue
            property.siteType =
                siteTypeValueSelected   // as it's listener is called in this activity so not working
            property.accessRoad = accessRoadAdapter.getSelectedItem()?.paramValue
            property.powerSourceType =
                powerSourceTypeValueSelected// as it's listener is called in this activity so not working

            //getting from yes/no spinners

            if (isRooftopSelected) {
                property.pentHouseAvailable =
                    if (binding.pentHouseAvailableSpinner.selectedItem.toString() == getString(R.string.choose_an_option)) "" else binding.pentHouseAvailableSpinner.selectedItem.toString()
            } else {
                property.pentHouseAvailable = ""
            }
            property.candidateCompliedWithMOMRARegulations =
                if (binding.momraRegulationsSpinner.selectedItem.toString() == getString(R.string.choose_an_option)) "" else binding.momraRegulationsSpinner.selectedItem.toString()

            if (isSCECOSelected) {
                property.ownerApprovalToInstallSubStation =
                    if (binding.ownerApprovalToInstallSubStationSpinner.selectedItem.toString() == getString(
                            R.string.choose_an_option
                        )
                    ) "" else binding.ownerApprovalToInstallSubStationSpinner.selectedItem.toString()
                property.scecoAccessToRoad =
                    if (binding.secoAccessToRoadSpinner.selectedItem.toString() == getString(R.string.choose_an_option)) "" else binding.secoAccessToRoadSpinner.selectedItem.toString()
            } else {
                property.ownerApprovalToInstallSubStation = ""
                property.scecoAccessToRoad = ""
            }


            property.availablePowerSourceFromOwner =
                if (binding.availablePowerSourceOwnerSpinner.selectedItem.toString() == getString(R.string.choose_an_option)) "" else binding.availablePowerSourceOwnerSpinner.selectedItem.toString()
            property.obstructionExist =
                if (binding.obstructionsExistSpinner.selectedItem.toString() == getString(R.string.choose_an_option)) "" else binding.obstructionsExistSpinner.selectedItem.toString()
            property.landlordApproval =
                if (binding.landlordApprovalSpinner.selectedItem.toString() == getString(R.string.choose_an_option)) "" else binding.landlordApprovalSpinner.selectedItem.toString()
            property.ownerDeedAndIdDoc =
                if (binding.landDeedAvailableSpinner.selectedItem.toString() == getString(R.string.choose_an_option)) "" else binding.landDeedAvailableSpinner.selectedItem.toString()

        }

        saveCandidateDetailsToRoom(currentCandidateDetailsResponse, saveToApi)
    }

    private fun saveCandidateDetailsToRoom(
        candidateDetailsAPIResponse: CandidateDetailsAPIResponse,
        saveToApi: Boolean
    ) {
        val candidateDetailsDao = baseActivity.commonDatabase.candidateDetailsDao()
        disposable = candidateDetailsDao.insertCandidateDetails(candidateDetailsAPIResponse)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({
                MyApp.localTempVarStore.autoGeneratedID = autoGeneratedId
                saveDetailsToExistingCapturedCandidate(candidateDetailsAPIResponse)
                if (saveToApi) {
                    saveCandidateToApi(currentCandidateDetailsResponse)
                } else {
                    baseActivity.showToastMessage("Data saved to phone!")
                }
            }, { error ->
                baseActivity.showToastMessage("Unable to save to Phone!")
            })
    }

    private fun saveDetailsToExistingCapturedCandidate(candidateDetailsAPIResponse: CandidateDetailsAPIResponse) {
        if (candidateOrLandlordName.isNullOrEmpty()) {
            candidateOrLandlordName = "NA"
        }
        val newExistingCapturedCandidate =
            ExistingCandidateListResponse.ExistingCandidateListResponseItem(
                autoGeneratedId = autoGeneratedId,
                taskId = MyApp.localTempVarStore.taskId,
                _Id = null,
                landlordId = null,
                landlordName = candidateOrLandlordName,
                propertyId = candidateDetailsAPIResponse.propertyDetail?.propertyId,
                propertyCity = candidateDetailsAPIResponse.propertyDetail?.siteCity,
                propertyDistrict = candidateDetailsAPIResponse.propertyDetail?.siteDistrict,
                candidateId = candidateDetailsAPIResponse.candidateId
            )
        disposable =
            baseActivity.commonDatabase.existingCandidateListResponseItemDao()
                .insert(newExistingCapturedCandidate)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe({ _ ->
                    // no need
                }, { _ ->
                    // Handle error
                })
    }

    private fun saveCandidateToApi(candidateDetailsResponse: CandidateDetailsAPIResponse) {
        if (!checkApiValidation(candidateDetailsResponse)) return
        candidateDetailsResponse.propertyDetail ?: return
        val lsmUserId = KotlinPrefkeeper.lsmUserId ?: ""  // was used earlier
        val observable: Observable<UpdatePropertyResponse> =
            api!!.updateEssentialProperties(
                tenantId = KotlinPrefkeeper.leaseManagementUserID!!,
                taskId = MyApp.localTempVarStore.taskId,
                body = candidateDetailsResponse.propertyDetail!!
            )
        observable.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(object :
                Observer<UpdatePropertyResponse> {
                override fun onSubscribe(d: Disposable) {
                }

                override fun onNext(updatedPropertyResponse: UpdatePropertyResponse) {
                    baseActivity.showToastMessage("Updated to api")
                    updatePropertyIDToExistingCandidateAndDetails(
                        updatedPropertyResponse,
                        candidateDetailsResponse
                    )
                }

                override fun onError(e: Throwable) {
                    baseActivity.showToastMessage("unable to update to api")
                }

                override fun onComplete() {
                }
            })
    }

    private fun updatePropertyIDToExistingCandidateAndDetails(
        updatedPropertyResponse: UpdatePropertyResponse,
        candidateDetailsResponse: CandidateDetailsAPIResponse
    ) {
        candidateDetailsResponse.propertyDetail?.propertyId =
            updatedPropertyResponse.data?.propertyId
        candidateDetailsResponse.candidateId =
            updatedPropertyResponse.data?.candidateId
        binding.propertyIdET.setText(updatedPropertyResponse.data?.propertyId ?: "")
        saveCandidateDetailsToRoom(candidateDetailsResponse, false)
    }

    private fun checkApiValidation(currentCandidateDetailsResponse: CandidateDetailsAPIResponse): Boolean {
        if (currentCandidateDetailsResponse.propertyDetail == null) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        val property = currentCandidateDetailsResponse.propertyDetail!!
        if (property.landlordPrice.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.region.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteDistrict.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteCity.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteAddress.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteStreet.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteStreetInArabic.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.distanceFromRoadInMeter == null) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteNeighbourhood.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteNeighbourhoodInArabic.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.areaType.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.latitude.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.longitude.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.distanceFromNominalInMeter == null) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.leasedSpaceType.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteType.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        } else {
            if (isRooftopSelected) {
                if (property.approxBuildingHeightWithoutParapetInMeter == null) {
                    baseActivity.showToastMessage(mandatoryFieldsAreRequired)
                    return false
                }
                if (property.pentHouseAvailable.isNullOrEmpty()) {
                    baseActivity.showToastMessage(mandatoryFieldsAreRequired)
                    return false
                }
            }
        }


        if (property.candidateCompliedWithMOMRARegulations.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.accessRoad.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }

        if (property.powerSourceType.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        } else {
            if (isSCECOSelected) {
                if (property.ownerApprovalToInstallSubStation.isNullOrEmpty()) {
                    baseActivity.showToastMessage(mandatoryFieldsAreRequired)
                    return false
                }
                if (property.scecoAccessToRoad.isNullOrEmpty()) {
                    baseActivity.showToastMessage(mandatoryFieldsAreRequired)
                    return false
                }
                if (property.powerSourceDistanceFromSubstation == null) {
                    baseActivity.showToastMessage(mandatoryFieldsAreRequired)
                    return false
                }
                if (property.powerSourceDistanceFromRoad == null) {
                    baseActivity.showToastMessage(mandatoryFieldsAreRequired)
                    return false
                }
            }
        }

        if (property.availablePowerSourceFromOwner.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.siteArea.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.leaseAreaInSqMtr == null) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.nearestElectricityPointDistanceInMeter == null) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.obstructionExist.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.landlordApproval.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        if (property.ownerDeedAndIdDoc.isNullOrEmpty()) {
            baseActivity.showToastMessage(mandatoryFieldsAreRequired)
            return false
        }
        return true
    }

    private fun getCandidateData(propertyId: String? = null) {
        val candidateDetailsDao = baseActivity.commonDatabase.candidateDetailsDao()
        disposable = candidateDetailsDao.getCandidateDetailsByAutoGeneratedId(autoGeneratedId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ candidateDetailsResponse ->
                if (candidateDetailsResponse.propertyDetail != null) { // need to get candidate details
                    currentCandidateDetailsResponse =
                        candidateDetailsResponse
                    fillCandidateDetails(candidateDetailsResponse)
                }
            }, { error -> // error as details not present so, not filling details
            })

    }

    private fun fillCandidateDetails(
        candidateDetailsResponse: CandidateDetailsAPIResponse,
        isClearAllClicked: Boolean = false
    ) {
        val uniqueRegions: List<LocationsListResponse.LocationsListResponseItem>? =
            getLocationListForUniqueRegions()

        var regionSelected: String? = null
        var districtSelected: String? = null
        var citySelected: String? = null

        var districtsForSelectedRegion: List<LocationsListResponse.LocationsListResponseItem>? =
            null
        var cityForSelectedDistrict: List<LocationsListResponse.LocationsListResponseItem>? =
            null

        candidateDetailsResponse.propertyDetail?.let { property ->
            if (!isClearAllClicked) {     // update only when clear all not clicked
                binding.propertyIdET.setText(
                    property.propertyId ?: ""
                )
            }
            binding.landlordPriceEt.setText(property.landlordPrice ?: "")
            binding.siteAddressET.setText(property.siteAddress ?: "")
            binding.siteDistrictArabicValue.setText(property.siteDistrictLocal ?: "")
            binding.siteCityArabicValue.setText(property.siteCityLocal ?: "")
            binding.siteStreetEt.setText(property.siteStreet ?: "")
            binding.siteStreetArabicEt.setText(property.siteStreetInArabic ?: "")
            binding.distanceFromRoadEt.setText(property.distanceFromRoadInMeter?.toString() ?: "")
            binding.siteNeighbourhoodEt.setText(property.siteNeighbourhood ?: "")
            binding.siteNeighbourhoodArabicEt.setText(property.siteNeighbourhoodInArabic ?: "")

            binding.latitudeEt.setText(property.latitude ?: "")
            binding.longitudeEt.setText(property.longitude ?: "")
            binding.distanceFromNominalValue.setText(
                property.distanceFromNominalInMeter?.toString() ?: ""
            )

            binding.approxBuildingHeightWithoutParaperET.setText(
                property.approxBuildingHeightWithoutParapetInMeter?.toString() ?: ""
            )

            //         binding.ownerApprovalToInstallSubstationET.setText(
//                property.ownerApprovalToInstallSubStation ?: ""
//            )
            binding.powerSourceDistanceSubstationET.setText(
                property.powerSourceDistanceFromSubstation?.toString() ?: ""
            )
            binding.powerSourceDistanceRoadET.setText(
                property.powerSourceDistanceFromRoad?.toString() ?: ""
            )
            //      binding.scecoAccessToRoadET.setText(property.scecoAccessToRoad ?: "")
            binding.siteAreaLengthWidthET.setText(property.siteArea ?: "")
            binding.leaseAreaET.setText(property.leaseAreaInSqMtr?.toString() ?: "")
            binding.nearestElectricityPointDistanceET.setText(
                property.nearestElectricityPointDistanceInMeter?.toString() ?: ""
            )
            binding.distanceFromNearestOperatorET.setText(
                property.distanceFromNearestOperatorTower?.toString() ?: ""
            )
            binding.potentialPropertyStatusET.setText(property.potentialPropertyStatus ?: "")


            //filling API spinners
            selectPositionForApiSpinners(binding.areaTypeSpinner, property.areaType, areaTypeList)
            selectPositionForApiSpinners(
                binding.leaseSpaceTypeSpinner,
                property.leasedSpaceType,
                leaseSpaceTypeList
            )
            selectPositionForApiSpinners(binding.siteTypeSpinner, property.siteType, siteTypeList)
            selectPositionForApiSpinners(
                binding.accessRoadRequiredSpinner,
                property.accessRoad,
                accessRoadList
            )
            selectPositionForApiSpinners(
                binding.powerSourceTypeSpinner,
                property.powerSourceType,
                powerSourceTypeList
            )


            // filling yes no spinners
            selectPositionForYesNoSpinners(
                binding.pentHouseAvailableSpinner,
                property.pentHouseAvailable
            )
            selectPositionForYesNoSpinners(
                binding.momraRegulationsSpinner,
                property.candidateCompliedWithMOMRARegulations
            )
            selectPositionForYesNoSpinners(
                binding.ownerApprovalToInstallSubStationSpinner,
                property.ownerApprovalToInstallSubStation
            )
            selectPositionForYesNoSpinners(
                binding.secoAccessToRoadSpinner,
                property.scecoAccessToRoad
            )
            selectPositionForYesNoSpinners(
                binding.availablePowerSourceOwnerSpinner,
                property.availablePowerSourceFromOwner
            )
            selectPositionForYesNoSpinners(
                binding.obstructionsExistSpinner,
                property.obstructionExist
            )
            selectPositionForYesNoSpinners(
                binding.landlordApprovalSpinner,
                property.landlordApproval
            )
            selectPositionForYesNoSpinners(
                binding.landDeedAvailableSpinner,
                property.ownerDeedAndIdDoc
            )

            //for location selection spinners getting lists for dist based on region and city based on district
            districtsForSelectedRegion = getLocationsListForDistrictsInRegion(property.region)
            cityForSelectedDistrict = getLocationsListForCitiesInDistrict(property.siteDistrict)
            regionSelected = property.region
            districtSelected = property.siteDistrict
            citySelected = property.siteCity

        }

        attachValuesToLocationsSpinners(
            uniqueRegions,
            districtsForSelectedRegion,
            cityForSelectedDistrict, regionSelected, districtSelected, citySelected
        )
    }

    private fun attachValuesToLocationsSpinners(
        uniqueRegions: List<LocationsListResponse.LocationsListResponseItem>? = null,
        districtsForSelectedRegion: List<LocationsListResponse.LocationsListResponseItem>? = null,
        cityForSelectedDistrict: List<LocationsListResponse.LocationsListResponseItem>? = null,
        regionSelected: String? = null,
        districtSelected: String? = null, citySelected: String? = null
    ) {
        regionAdapter = createRegionSpinnerAdapter(uniqueRegions ?: listOf())
        regionAdapter.attachSpinner(binding.regionSpinner)
        val positionRegion =
            uniqueRegions?.indexOfFirst { it.regionName == regionSelected } ?: -1
        if (positionRegion != -1) {
            binding.regionSpinner.setSelection(positionRegion)
        }

        lifecycleScope.launch(Dispatchers.Main) {
            delay(200)
            districtAdapter = createDistrictSpinnerAdapter(districtsForSelectedRegion ?: listOf())
            districtAdapter.attachSpinner(binding.districtSpinner)

            delay(400)
            val position =
                districtsForSelectedRegion?.indexOfFirst { it.districtName == districtSelected }
                    ?: -1
            if (position != -1) {
                binding.districtSpinner.setSelection(position)
            }
        }
        lifecycleScope.launch(Dispatchers.Main) {
            delay(600)
            cityAdapter = createCitySpinnerAdapter(cityForSelectedDistrict ?: listOf())
            cityAdapter.attachSpinner(binding.citySpinner)

            delay(800)
            val position =
                cityForSelectedDistrict?.indexOfFirst { it.cityName == citySelected } ?: -1
            if (position != -1) {
                binding.citySpinner.setSelection(position)
            }
        }
    }

    private fun createRegionSpinnerAdapter(
        locationList: List<LocationsListResponse.LocationsListResponseItem>,
    ): SpinnerGenericLocationAdapter {
        return SpinnerGenericLocationAdapter(
            context = baseActivity,
            items = locationList,
            object : SpinnerGenericLocationAdapter.OnItemSelectedListener {
                override fun onItemSelected(
                    item: LocationsListResponse.LocationsListResponseItem,
                    position: Int
                ) {
                    if (::districtAdapter.isInitialized) {
                        item.regionName ?: return
                        val districtLocationList =
                            getLocationsListForDistrictsInRegion(item.regionName) ?: return
                        districtAdapter.updateData(districtLocationList)
                        cityAdapter.updateData(listOf())
                        binding.siteDistrictArabicValue.setText("")
                        binding.siteCityArabicValue.setText("")
                    }
                }
            },
            AreaType.REGION
        )
    }

    private fun createDistrictSpinnerAdapter(
        locationList: List<LocationsListResponse.LocationsListResponseItem>,
    ): SpinnerGenericLocationAdapter {
        return SpinnerGenericLocationAdapter(
            context = baseActivity,
            items = locationList,
            object : SpinnerGenericLocationAdapter.OnItemSelectedListener {
                override fun onItemSelected(
                    item: LocationsListResponse.LocationsListResponseItem,
                    position: Int
                ) {
                    if (::cityAdapter.isInitialized) {
                        item.districtName ?: return
                        val cityLocationList =
                            getLocationsListForCitiesInDistrict(item.districtName) ?: return
                        cityAdapter.updateData(cityLocationList)
                        item.districtLocalName?.let { binding.siteDistrictArabicValue.setText(it) }
                    }
                }
            },
            AreaType.DISTRICT
        )
    }

    private fun createCitySpinnerAdapter(locationList: List<LocationsListResponse.LocationsListResponseItem>): SpinnerGenericLocationAdapter {
        return SpinnerGenericLocationAdapter(
            context = baseActivity,
            items = locationList,
            object : SpinnerGenericLocationAdapter.OnItemSelectedListener {
                override fun onItemSelected(
                    item: LocationsListResponse.LocationsListResponseItem,
                    position: Int
                ) {
                    item.cityLocalName?.let { binding.siteCityArabicValue.setText(it) }
                }

            },
            AreaType.CITY
        )
    }


    private fun selectPositionForYesNoSpinners(
        spinner: Spinner,
        value: String?
    ) {
        value ?: return
        val predefinedValues = listOf("Choose an option", "Yes", "No", "Unavailable")
        val position = predefinedValues.indexOf(value)
        if (position != -1) {
            spinner.setSelection(position)
        }
    }

    private fun selectPositionForApiSpinners(
        spinner: Spinner,
        paramValue: String?,
        dropdownList: List<DropdownDataResponse.DropdownDataResponseItem>
    ) {
        paramValue ?: return
        val position = dropdownList.indexOfFirst { it.paramValue == paramValue }
        if (position != -1) {
            spinner.setSelection(position)
        }
    }

}